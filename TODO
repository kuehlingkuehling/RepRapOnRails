
Zwei verlinkte SerialPorts erstellen:
$ socat -d -d pty,raw,echo=0 pty,raw,echo=0

Konfiguration über Oberfläche:
  - Timezone (Dropdown Liste o.ä.)
  - Password (für Browseroberfläche) - on screen keyboard?
  - Print Time Counter - zurückstellbar (auf null)

Websocket-Action:
  messages.notice und messages.error
  - sollen nachricht in html template rendern und über websocket schicken
  - html wird dann an #messages div angehängt und über jquery die "in" class
  - hinzugefügt, um einzufaden über CSS3 transition
  
  
File Uploads im Browser Formular:
  - über jQuery plugin https://github.com/blueimp/jQuery-File-Upload
  - fertiges Rails gem davon: https://github.com/tors/jquery-fileupload-rails
  - ...nur noch einbinden, konfigurieren im form (im view) (nur ein file, max file size etc), fertig.
  
Rails App komplett nur über SSL anbieten!
  - in config/application.rb
    config.force_ssl = true
  - thin server mit SSL starten:
    $ thin start --ssl
  - http://www.railway.at/2013/02/12/using-ssl-in-your-local-rails-environment/
  
Update Strategie:
  - Upload der neuen App über Controller-Backend als .tar.gz,
    wird neben dem Ordner des aktuellen Controllers gespeichert
  - im kiosk-script läuft vor dem Rails-Server-Start ein update-rails-app.rb script:
      1. controller-ordner löschen
      2. archiv entpacken
      3. archiv löschen
      4. "bundle install" im ordner ausführen, fertig.
  
On Screen Keyboard - zwei alternativen:
  - http://project.cahnory.fr/jquery.keyboard/
    hübsch, fährt von unten in voller breite hoch, customizable
  - https://github.com/Mottie/Keyboard
    Keyboard das über dem input-field aufpoppt und sich (wohl) ans aktuelle design
    anpasst
    
    BEISPIEL
    >>>>>>>>>>>>> http://jsfiddle.net/Mottie/MK947/
    
GCODE File Uploads via CarrierWave
  - https://github.com/carrierwaveuploader/carrierwave
  - speicherort: /public/uploads
  
GCODE processing im background (estimated print time berechnen)
  - https://github.com/lardawge/carrierwave_backgrounder
    
WICHTIG: /printer/index als "initializing" page
  - um zum controller zu connecten und ggf. zu wiederholen, falls der "online"
    callback nicht registriert wird oder sonst irgendetwas schief läuft
   